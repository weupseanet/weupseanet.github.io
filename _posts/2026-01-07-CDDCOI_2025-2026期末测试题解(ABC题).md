---
layout: post
title: "CDDCOI_2025-2026期末测试题解(ABC题)"
date: 2026-01-07
---


### 前言
对于一些代码，我放在个人Blog网站中(Jgjingsgo个人主页-Github站)
### A. 睡吧，我亲爱的小鸽子呀
这道题是判断奇偶性。
在数量n为奇数时，双方都选最优解，你是永远赢不了的。
#### 可能AC CODE
```cpp
#include <cstdio>
typedef long long ll;
ll n , k;

int main() {
	scanf("%lld %lld" , &n , &k);
	if(n % 2 == 1) 
		printf("No");
	else 
		printf("Yes");
	return 0;
}
```
### B. 愿繁花与美梦盛开在你窗边
贪心做法，选择离i最近的，若两边都是则通过，若有一个不是就更改
#### 可能AC CODE
```cpp
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;

string s;
int ans , n;

int find_l(int x) {
	while(x >= 0 && s[-- x] == 'R');
	return x;
}
int find_r(int x) {
	while(x < n && s[++ x] == 'B');
	return x;
}

int main () {
	cin >> s;
	n = s.length();
	if(s[0] == 'R') 
		ans ++ , s[0] = 'B';
	if(s[n - 1] == 'R') 
		ans ++ , s[n - 1] = 'B';
	
	for(int i = 1;i < n - 1;i ++) 
		if(s[i] == 'R') {
			int fl = find_l(i) , fr = find_r(i);
			int ll = i - fl , rr = fr - i;
			int d = min(ll , rr);
			if(s[i + d] == 'R') 
				ans ++ , s[i + d] = 'B';
			if(s[i - d] == 'R') 
				ans ++ , s[i + d] = 'B';
		}
	
	cout << ans;
	return 0;
}
```
### C. 即便尘埃玷染你洁白的羽毛
`pre_max`存最优解，加上前缀和优化。
(wa,wb,wc为a,b,c的前缀和)
可以的出:
```
pre_max[i] = max(pre_max[i - 1], wa[i] - wb[i]);
ans = max(ans, pre_max[i - 1] + wb[i] - wc[i]);
```
#### 可能AC CODE
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MAXN = 300000 + 5;
ll a[MAXN], b[MAXN], c[MAXN];
ll wa[MAXN], wb[MAXN], wc[MAXN];
ll pre_max[MAXN];
int n;

int main() {
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
		wa[i] = wa[i - 1] + a[i];
	}
	for (int i = 1; i <= n; i++) {
		cin >> b[i];
		wb[i] = wb[i - 1] + b[i];
	}
	for (int i = 1; i <= n; i++) {
		cin >> c[i];
		wc[i] = wc[i - 1] + c[i];
	}
	
	ll ans = LLONG_MIN;
	pre_max[1] = wa[1] - wb[1];
	for (int i = 2; i < n; i++) {
		pre_max[i] = max(pre_max[i - 1], wa[i] - wb[i]);
		ans = max(ans, pre_max[i - 1] + wb[i] - wc[i]);
	}
	
	cout << ans + wc[n] << "\n";
	return 0;
}
```